# 操作系统哈工大

## 启动

图灵机一条带（取指执行） ==>>   冯诺依曼包装起来，一整个程序通过PC交由CPU计算。加载到内存才能取指执行

**打开电源执行的第一条指令  PC = ？？？内存中有什么 ？？？**

X86的PC   ==>>  CS << 4 + IP

PC由硬件决定

开机后取指执行，检查硬件情况，把磁盘0磁道0扇区（引导扇区）读入0x7c00处，设置PC,执行bootsect.s汇编代码（把引导扇区的代码移动，让出位置），代码继续执行，通过中断（int 0x13）载入setup模块, setup模块记录硬件信息，通过中断向屏幕打印字符。控制权交由setup模块，bootsect.s退出舞台。

setup初始化，获取内存大小（管理内存得先获取内存大小才能用数据结构管理），获取硬件参数信息，并把操作系统移动到0的位置，之前让出的位置就是以免这里的移动覆盖了setup，因为setup还没工作完。最后一个关键是进入保护模式改变寻址方式扩大寻址范围。之前都是16位寻址，15位最大寻址为1M所以得扩大。

跳转到head.s操作系统模块的第一个汇编，初始化GDT和IDT表项，跳转到main.c（第一个c程序）启动后初始化各项管理硬件的数据结构，一直在跑。操作系统代码放在了内存的零地址，应用程序在上端，通过系统调用的中断进入操作系统。

### bootsect.s

![image-20220104111402540](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104111402540.png)

![image-20220104111812058](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104111812058.png)

中断读入setup模块（4个扇区）再读入操作系统模块

![image-20220104111858235](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104111858235.png)

### setup模块

加载和打印字符logo

![image-20220104112310259](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104112310259.png)

![image-20220104112329122](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104112329122.png)

初始化完成后，进入保护模式

![image-20220104113249351](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104113249351.png)

![image-20220104113521605](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104113521605.png)

间接寻址，查找中间表

![image-20220104113545119](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104113545119.png)

### head.s

![image-20220104113800955](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104113800955.png)

初始化gdt和idt表

![image-20220104114012780](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104114012780.png)

启动中用到了3种汇编

![image-20220104114159494](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104114159494.png)



### main.c

![image-20220104122016764](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104122016764.png)

![image-20220104122026015](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104122026015.png)

清空内存非系统使用的地方变为零

![image-20220104122048240](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104122048240.png)

### 进入操作系统

通过系统调用中的中断代码进入到内核



操作系统在后台跑着，并开启shell等待用户的输入执行进程

![image-20220104141238892](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104141238892.png)

消息队列 + 消息处理程序

![image-20220104141705395](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104141705395.png)

统一系统调用接口标准，可以实现夸平台

![image-20220104141901750](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104141901750.png)

为了安全需要区分用户态和内核态

![image-20220104143646230](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104143646230.png)

通过硬件设计，目标端寄存器和源寄存器，进入的时候区分内核端还是用户段

![image-20220104145349494](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104145349494.png)

中断把目的寄存器权限位改成3，进入到系统后把源寄存器权限位改成0

![image-20220104145507801](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104145507801.png)

中断是进入系统的唯一方式，系统调用通过宏展开包涵里面的int0x80 （进入到操作系统）

![image-20220104145602283](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104145602283.png)

进入中断的关键代码（在call表，找到对应的系统调用）

![image-20220104150244289](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150244289.png)

![image-20220104150342389](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150342389.png)



## 历史

![image-20220104150618855](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150618855.png)

![image-20220104150656309](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150656309.png)

![image-20220104150727281](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150727281.png)

简单的取指执行cpu利用率会大大降低，遇到IO操作需要等很久

![image-20220104150825995](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150825995.png)

出现了多道程序，交替执行提高利用率

![image-20220104150932962](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104150932962.png)



## 多进程的视图

系统管理多个进程向前推荐，操作系统的重要部分

### 进程运行

![image-20220104152413693](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104152413693.png)

![image-20220104152517691](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104152517691.png)



### 进程切换

![image-20220104152617902](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104152617902.png)

进程的状态队列，（就绪、等待、执行），切换的策略

![image-20220104153019812](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104153019812.png)

![image-20220104153054859](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104153054859.png)

![image-20220104152703703](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104152703703.png)

#### 出现的问题

内存地址相同时有问题

![image-20220104153251752](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104153251752.png)

出现了对内存的管理MMU，虚拟内存映射，每个PCB有一个映射表

![image-20220104153340280](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104153340280.png)



进程的合作会出现竞争（生产者，消费者模型）

![image-20220104153458879](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104153458879.png)

当还没执行完就切换的时候导致两个进程读取的数据不一致，需要加锁

![image-20220104153558231](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104153558231.png)



#### 引入用户级线程

进程切换需要保存上下文，消耗时间久。拆成多个指令序列。线程比进程的切换少切了内存的映射表。

![image-20220104154025712](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154025712.png)

例如一个服务器可以拆开多个指令做不同任务，并且他们共享同一资源

![image-20220104154244298](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154244298.png)

通过yield切换让出cpu，切换也得保存上下文，所以得需要栈保存切出去的时候的返回地址。

![image-20220104154409615](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154409615.png)

![image-20220104154624031](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154624031.png)

如果这个栈共用的话，切回来的时候就找不到对应线程的返回地址，所以抽出一个和进程一样的数据结构（PCB, TCB）

![image-20220104154804960](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154804960.png)

![image-20220104154847817](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154847817.png)

create的时候创建数据结构，把数据结构初始化，切出去的时候保存上下文

![image-20220104154945319](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104154945319.png)



#### 引入内核级线程

进程的切换是在内核中的（因为要分配资源，访问内存文件等），进程的切换就是内核级线程切换加上一些资源表的切换，不像用户级线程一样可以随意切换。

用户级线程，不用管操作系统，是内核级的一个子部分（因为了解了指令序列怎么切换）

用户级线程，操作系统感知不到，当其中一个线程需要IO时，操作系统因为时间问题会切换另一个进程，那么刚刚那个进程里面的多个线程就没作用了

![image-20220104155439866](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104155439866.png)

![image-20220104155538483](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104155538483.png)



因为内核级线程，多核才有了意义。

![image-20220104155638660](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104155638660.png)

TCB切换内核和用户态都要切

![image-20220104155834596](C:\Users\Admin\Desktop\study\study\操作系统\操作系统哈工大\image-20220104155834596.png)